// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Rscv_Math from "./Rscv_Math.mjs";
import * as Belt_Array from "@rescript/std/lib/es6/belt_Array.js";
import * as Belt_Option from "@rescript/std/lib/es6/belt_Option.js";
import * as Caml_option from "@rescript/std/lib/es6/caml_option.js";

function joinWith(args, init, delim) {
  return Belt_Array.reduce(args, init, (function (a, b) {
                return a + delim + b;
              }));
}

function join(args, init) {
  return joinWith(args, init, "");
}

function count(value, token) {
  return Belt_Array.keep(value.split(""), (function (x) {
                return x === token;
              })).length;
}

function $$parseInt(value, radix) {
  var parseIntSingleString = function (value) {
    var x = (value.charCodeAt(0) | 0) - 48 | 0;
    if (x >= 0 && x <= 9) {
      return x;
    }
    
  };
  var x = Belt_Array.map(value.split(""), parseIntSingleString);
  if (Belt_Array.every(x, Belt_Option.isSome)) {
    return Rscv_Math.Int.sum(Belt_Array.mapWithIndex(Belt_Array.map(Belt_Array.reverse(x), Belt_Option.getExn), (function (i, x) {
                      return Math.imul(Math.pow(radix, i) | 0, x);
                    })));
  }
  
}

function make(string) {
  return Belt_Option.flatMap(Belt_Option.flatMap(Belt_Option.map(Caml_option.null_to_opt(/(#[0-9a-f]+)/.exec(string)), (function (x) {
                        return x;
                      })), (function (x) {
                    return Belt_Array.get(x, 1);
                  })), (function (prim) {
                if (prim == null) {
                  return ;
                } else {
                  return Caml_option.some(prim);
                }
              }));
}

var Hex = {
  make: make
};

export {
  join ,
  joinWith ,
  count ,
  $$parseInt ,
  Hex ,
  
}
/* No side effect */
